-------------
Установка Git
-------------
** В Debian:
#	apt install git

** Вывести номер установленной версии:
$	git --version

--------------------
Графические клиенты:
--------------------
** gitk	#запускается из папки проекта, позволяет просматривать историю;
** git-gui	#предназначен для формирования коммитов - можно видеть измененные файлы, понимать, что в них поменялось, добавлять комментарии.
	[Stage Changed] = git add
	[commit] = git commit

-------------
Настройка Git
-------------

$	git config
		--global		# Глобальная пользовательская настройка
			user.name "[name]"				# задать имя пользователя
			user.email "[email address]"	# -//- почтовый адрес -//-
			color.ui auto					# -//- автоматическую подсветку синтаксиса
			core.editor "[program]"			# -//- редактор текста по умолчанию (vi, vim, nano, mcedit, emacs и.т.д.)
		--list			# вывести список настроек Git
			--show-origin	# определить местоположение конфигурационного файла git-а
										# конфигурационный файл git-а можно править руками
------------------
Псевдонимы команд:
------------------
Для объемных команд можно использовать короткие запоминающиеся псевдонимы.
Создать псевдоним можно при помощи команды git config, добавив свойство alias, после него следует указать имя псевдонима.
Например:
Введем псевдоним gg для команды  git log с параметром - -graph: 

$ git config --global alias.gg 'log --pretty=format:"%C(yellow)%h%Creset -%C(green)%d%Creset %s %C(bold blue)(%cn) %C(green)%cd%Creset" --graph --date=format:"%d.%m.%Y %H:%M"'

----------------
Git репозитории:
----------------
Для того, чтобы начать пользоваться удаленным git-репозиторием, проще всего начать с готовых git-хостингов, например, GitHub или BitBucket.
Кроме хостинга, GitHub предоставляет мощный веб-интерфейс для управления Git-репозиторием,
	трекер задач, Wiki-редактор документации, поиск по проектам, статистику по кодовой базе и многое другое.
Если git-хостинги по каким-то причинам не подходят, можно развернуть свой собственный git-репозиторий:
	для этого достаточно виртуального сервера с SSH-доступом.
В случае, если помимо консольного доступа необходим веб-интерфейс, можно воспользоваться GitLab, который тоже можно развернуть на собственном сервере.
GitLab предоставляет веб-интерфейс для управления git-репозиториями, правами доступа и предоставляет схожий с Git-хостингами функционал.

-------------------------------
Создание локального репозитория
-------------------------------

** Cоздать локальный репозиторий в текущей папке:
$	git init

-------------
Структура Git
-------------

Репозитории бывают:
	1. Лоакальные (local);
	2. Удаленные (remote);

Структура репозитория:
.git - директория в которой содержится вся конфигурация и снимки репозитория:
	./hooks/
	./info/
	./objects/
	./refs/
	./config
	./description
	./HEAD

Структура истории коммитов:
(HEAD -> <branch>)	# в истории коммитов указывает на текущую ветку
commit				# хэш коммита (используется SHA-1: Это строка длинной в 40 символов в HEX формате
					## Хэш вычисляется на основе содержимого файла или структуры каталога.
					## Для удобства можно сократить хеш до 7-8 символов)
Author				# автор коммита (имя и email)
Date				# дата и время создания коммита

Файлы Git:
README.md	- обычно содержит описание для текущего репозитория либо директории
.gitkeep	- пустой файл, создается в пуостой директории для ее фиксации в репозитории
.gitignore	- в файле указываются названия файлов и дерикторий (можно шаблонами), которые не должны индексироваться в git (помещается в корень проекта)

# Ресурс http://gitignore.io/ позволяет автоматически формировать содержимое .gitignore-файла.
# Достаточно указать ключевые слова, например Sublime, Yii2, vim,
## и на их основе будет предложена заготовка для .gitignore, которая исключает временные и вспомогательные файлы.

Stash - локальное хранилище git для временного хранения изменений в ветке без их индексирования и фиксации
Сразу после создания проекта появляется основная ветка master (или main).

--------------------
Работа с изменениями
--------------------

** Проверка репозитория на необходимость фиксации изменений
$	git status
		-s		#упрощенный вывод - только перечень файлов:
					## ?? - неотслеживаемый, A - отслеживаемый, M - модифицированный;

** Вывод изменений (сравнение):
$	git diff		#Покажет различия между файлами в последнем снимке и текущим состоянием (показывает изменения только в отслеживаемых файлах!!!).
		--cached	#Показывает изменения которые попали в индекс (после git add), готовые к коммиту.

** Откатить состояние файла до последнего коммита:
$	git checkout -- <file_name>

** Добавить файл к будущему коммиту (добавить в индекс)
$	git add <file>
		.	# добавляет в индекс все новые файлы
** Записать коммит (зафиксировать изменения)
$	git commit - записать коммит (зафиксировать изменения)
		-a						# добавить в индекс и зафиксировать изменения (используется для уже добавленных ранее файлов)
		-m 'commit message'		# записать коммит с сообщением
		--amend					# записать изменения в последний коммит (!!!перед этим добавить изменения в индекс!)
** Просмотреть информацию о коммите:
$	git show		# информация о текущем коммите;
		<tag>		# информация по конкретному тэгу;
		<commit>	# информация по конкретному коммиту;
		HEAD		# указывает на последний коммит;
		HEAD~<порядковый_номер>		# Указывает на коммит с порядковым номером относительно текущего;

-----------------------------------
Работа с временным хранилищем Stash
-----------------------------------
!!! Перед "откладыванием" изменений их необходимо проиндексировать (git add)!!!

$	git stash
		list				# посмотреть список stash хранилищ
		apply				# вернуть изменения спрятанные в stash списке
						## Каждое сохранение в stash маркируется номером stash-записи (метки).
						## Apply, по умолчанию, возвращает изменения с последней меткой.
			stash@{номер_метки}	# Вернуть изменения сохраненные под определенным номером.
		drop				# Удалить все записи в stash
		push <file>			# добавить файл в существующий на текущей ветке stash
		pop <stash>			# применить изменения из stash хранилища с указанным номером

----------------
Просмотр истории
----------------

** Просмотр истории коммитов:
$	git log
		--oneline	# просмотр истории коммитов кратким списком (сокращенный хэш)
		--all		# посмотреть истории коммитов со всех веток
		-<число>	# ограничить вывод количеством последних коммитов
		-p		# детальная информация по коммитам
		--stat		# вывод статистики по каждому коммиту
		--pretty=<формат_вывода>	# вывод истории в указанном формате
			oneline	# тоже что и --oneline, но хэш коммитов указывается полностью
			format: "%<имя_столбца(цвет, если нужно)> - %<имя_столбца>, %<имя_столбца> : %<имя_столбца>"		# указать свой формат вывода отчета по истории:
				h	# сокращенный хеш
				an	# автор
				ar	# сколько времени назад добавлен
				s	# комментарий
		--until=<число><единица_времени>		# позволяет задать дату, с которой мы начинаем поиск, например - 2.week
		--since=<число><единица_времени>		# задать, до какого момента в прошлом мы ищем коммиты.
								## допускается использовать и точные даты типа: 2019-03-01
		-S<искомый_текст>				# поиск коммита где добавлен этот текст
		- -author="имя_автора"				# вывод коммитов указанного автора
		--graph						# кометы со всех веток с зависимостями (включая слияния)
		--date=format:"%d.%m.%Y %H:%M			# задаем формат времени в выводе

** Просмотр истории действий:
$	git reflog
		
** Вывести список коммитов по конкретному файлу:
$	git blame <имя_файла>

-----------------
Изменение истории
-----------------

** Cброс текущего состояния файла до последнего коммита:
$	git restore <file>

** Сброс текущего состояния истории до указанного коммита:
$	git reset
		--hard			# жесткий сброс без сохранения изменений
		HEAD <filename>		# удалить изменения внесенные в индекс - вернув к последнему комету текущей ветки.

** Cоздать новый коммит, отменяющий последствия указанного коммита:
$	git revert <hash_commit>


------------------------------------
Рабочий процесс - правила ветвления:
------------------------------------

** Gitflow — это набор правил ветвления, который позволяет управлять релизами проекта.
Эти правила определяют, какие ветки нужно создавать и как производить их слияние.

Для работы по Gitflow создаются две постоянные ветки: master и develop.
Это долгоиграющие ветки, они существуют на всем протяжении жизненного цикла проекта.

Ветка master считается главной, в каждый момент времени код в ней должен быть готов к релизу (его установка в продакшн-среду не должна приводить к поломке).
Ветка develop используется для разработки, в ней должны содержаться самые последние изменения,
	необходимые для следующего релиза. Когда исходный код в ветке develop достигает стабильного состояния и готов к релизу,
	все изменения должны быть влиты в ветку master и помечены тегом с номером релиза.

В качестве вспомогательных веток используются:
----------------------------------------------

* ветки задач, в которых разработчики решают конкретные поставленные задачи.
	Ветки задач используются для разработки новых функций, которые должны появиться в текущем или будущем релизах.
	Как правило, они отпочковываются от ветки develop, хотя это необязательно.
	В начале работы над задачей может быть еще не известно, в какой именно релиз она будет добавлена.
	Ветка живет столько, сколько продолжается разработка функциональности.
	После того, как функционал разработан, ветка сливается в develop.
	Как правило, в трекере задач заводится тикет на функционал, номер задачи обычно добавляется в название ветки,
		чтобы в любой момент можно было бы обратиться к трекеру за подробным описанием.

* релизные ветки для сбора релиза.
	Релизная ветка используются для подготовки к выпуску новых версий продукта.
	Она нужна, чтобы в релиз попало не все содержимое develop-ветки, а лишь избранные задачи, например, ряд фич, которые пока нестабильны или не готовы к выкатке.
	Можно собрать в релизную ветку все задачи, которые должны войти в релиз.
	Так появляется возможность спокойно ее тестировать и стабилизировать для запланированного релиза, оставив ветку develop свободной для разработки релизов.

	Существует два подхода для формирования релизной ветки.

	Согласно первому, она создается заранее, перед стартом релиза, отпочковать ее можно от develop, если он стабилен, либо от ветки master.
	В этом случае ветки задач отпочковываются от master и сливаются в релизную ветку. По мере тестирования и нахождения ошибок ветка исправляется.
	В конце релизная ветка сливается и в develop, и в master.
	
	Согласно второму подходу, релизная ветка формируется из веток задач по мере их готовности.
	При этом ветки задач не удаляются, в любой момент можно пересобрать релизную ветку, исключив из нее ту или иную задачу.
	При таком подходе важно отпочковывать ветки задач от master,
		и вносить исправления именно в ветки задач, ни в коем случае не создавая коммиты в релизной ветке.
	Это связано с тем, что ветка может быть удалена и собрана снова.
	После того, как релизная ветка сливается в master, она может быть удалена, считается, что master-ветка готова к релизу.
	При этом на ветку master cтавится тэг с версией продукта. Как правило, при каждом релизе увеличивается минорная версия, т. е. средняя цифра в версии.

	
* hotfix-ветки для срочных исправлений после релизов.
	Бывает не просто протестировать все до конца перед выпуском продукта.
	Продакшен-среды могут быть больше и сложнее устроены, включать интеграции, которые сложно обеспечить на тестовых стендах.
	Конечным вариантом продукта пользуется более широкая аудитория,
		поэтому после выпуска релиза могут вскрываться дополнительные ошибки или отклонения от нормального поведения.
	Для их исправления используются hotfix-ветки.

	Как правило, изменения, которые нужно внести в кодовую базу, очень небольшие и очевидные.
	Если исправление ситуации требует длительного исследования или много времени на исправление,
		там, где это возможно, релиз стараются откатить на предыдущую стабильную версию.
	Hotfix-ветки всегда отпочковываются от master-ветки и сливаются и в master, и в develop.
	Так как хотфикс сливается непосредственно в ветку master, на него тоже ставится версия, при этом увеличивается номер патч-версии, т. е., последняя цифра.

** Таким образом, у нас имеется четыре параллельных потока:
	- ветки задач (feature),
	- develop-ветка с последней версией продукта,
	- релизная ветка с хотфиксами (release),
	- стабильная ветка master.

** Идеально, если под каждый из этих потоков имеется свой собственный стенд:
	- master-ветка — это продакшен-окружение;
	- релизная ветка и хотфиксы — это препрод, среда максимально близкая по своим параметрам
		и состоянию к продакшен-окружению;
	- develop-ветка — это стейджинг-окружение;
	- ветки задач — либо на втором стейджинге, либо на dev-машинах.

Разумеется, различные компании могут себе позволить разные расходы на инфраструктуру.
	У кого-то может быть лишь продакшен-окружение, у кого-то в дополнение может быть лишь препрод или один стейджинг.
	У кого-то может быть полный набор окружений, десятки стейджей или облачная инфраструктура, позволяющая разворачивать для тестирования каждую ветку задач.
	В зависимости от количества окружений, работа отдела тестирования строится по-разному.
	Чем больше стейджей, тем тщательней можно проверить продукт, быстрее и надежнее воспроизвести и локализовать ошибку.

----------------
Работа с ветками
----------------
** Показать ветки (знак "*" перед именем ветки - обозначает текущую ветку):
$	git branch
			<branch>			# создается новая ветка
			<branch_fork> <branch_parent>	# создать новую ветку от указанной ветки
			-d <branch>			# удалить указанную ветку
			-m <original_name final_name>	# сменить имя ветки
				# !!!если потребуется переименовать удаленную ветку, то сделать это одной командой довольно сложно. Проще всего создать на удаленном сервере копию ветки, а старую ветку удалить.
				# git branch <новая_ветка> origin/<с_какой_копируем>; git push origin <новая_ветка>; git push origin :<с_какой_копировали>
			-r				# показать список веток в удаленном репозитории

** Если в качестве командной оболочки используется bash, можно воспользоваться решением git-aware-promt ( https://github.com/jimeh/git-aware-prompt) ,
	который встраивает название текущей ветки в подсказку командной строки.
===>
$	cd
$	mkdir .bash
$	cd .bash
$	git clone https://github.com/jimeh/git-aware-prompt.git
*** При помощи команды source выполняется скрипт main.sh из проекта git-aware-prompt.
$	source "~/.bash/git-aware-prompt/main.sh
*** Модифицируем переменную окружения PS1 таким образом, чтобы в нее добавлялось название текущей ветки:
	export PS1= "\w \[\$txtcyn\]\$git_branch\[\$txtred\]\$git_dirty\[\$txtrst\]\$ "
$	cd <имя_проекта>	#должна смениться строка приглашения на вид: <имя_проекта> (<имя_ветки>)<статус_репозитория>$
<===

** Переключится на указанную ветку:
$	git checkout <branch>
		-b <branch>	# создать новую ветку и переключиться на нее
			<tag>	# создать ветку от коммита, помеченного указанным коммитом, и переключиться на нее.

** Сравнить ветки (сравниваются снимки файлов):
$	git diff <branch1> <branch2>

------------------------------------------
Слияние веток (Merge-request и Git rebase)
------------------------------------------

** Слияние указанной ветки в текущую ветку:
$	git merge <branch>
		<branch> --squash		# перенос всех изменений (слияние) с указанной ветки в текущую одним коммитом через squash

**	Cмена начала старта текущей ветки с последнего коммита указанной ветки без добавления нового коммита
$	git rebase <branch>
		-i HEAD~X - склеить Х коммитов начиная с текущего
	# в открывшемся файле можно в нижних коммитах заменить pick на f (fix up - перемещает все сообщения из ранних коммитов в текущий)
	## 	если перед каждым коммитом мы оставляем значение pick — они остаются, если squash — объединяются.
		!!! Должен остаться хотя бы один коммит, помеченный как pick.

------------------------------------
Работа с коммитами из соседних веток
------------------------------------
git cherry -v <branch>		# показать на сколько коммитов отличается текущая ветка от ветки <branch>
git cherry-pick <commit>	# перенести коммит из другой ветки на текущую ветку
!!! Если возникает конфликт - исправляем в целевом файле конфликт, git add, git cherry-pick --continue !!!
git cherry-pick <branch>	# перенести последний коммит ветки
git cherry-pick ..<branch>	# перенести все коммиты с ветки

-----------------------------------------
Работа с конфликтами (при слиянии веток):
-----------------------------------------
Конфликты обозначаются угловыми скобками (>>>>> , <<<<<), чтобы их было хорошо видно в коде.
В верхней части приводится код текущей ветки, в нижней — той ветви, которая сливается.
Нам нужно выбрать правильный вариант или написать новый, который учтет изменения из обеих частей.
Далее git add и git commit

--------------------------------
Версия программного обеспечения:
--------------------------------

Версии программного обеспечения, как правило, состоит из трех цифр, первая из которых называется мажорной, вторая — минорной, а третья — патч-версией.
M.m.pv

Мажорная версия меняется довольно редко, как правило, в случае кардинальной переработки программного продукта.
Минорная версия отвечает за регулярные релизы, в рамках которых добавляется новый функционал и исправляются ошибки.
В рамках патч-версии изменений в возможностях программного обеспечения не производится. Как правило, в рамках такой версии закрываются критические уязвимости.

Это не единственно возможный способ версионирования, например, можно ориентироваться на даты выхода продукта.

Какая бы модель версионирования не была выбрана, в системе контроля версий придется отметить коммит,
	который отвечает за версию, чтобы в любой момент времени иметь возможность собрать нужную версию продукта.
Такие кометы помечаются с помощью тегов (см. git tag).
Тэг — это всегда ссылка на коммит. На один и тот же коммит можно навесить множество тэгов.
Более того, хэш тоже можно рассматривать как тэг, просто его сложнее запомнить. Поэтому мы вводим свои собственные тэги, которые человеку запомнить гораздо проще.
Помимо наших собственных тэгов и хэш-кодов, git предоставляет несколько дополнительных тэгов. Один из них HEAD, указывает на последний коммит:

-------------------------------------
Работа с метками (также см. git push)
-------------------------------------
** Вывести список тегов
$	git tag
		<tag>				# фиксация версии (релиза) продукта тегом (меткой) по последнему коммиту
		-d <tag>			# удалить тег из локального репозитория
		-a <tag> -m '<комментария>'	# соответсвенно, создаем так с комментарием
		-l <маска>			# поиск тегов по маске.
			<commit>		# присвоить тэг определенному коммиту.

** запросить список тегов с удаленного репозитория

$	git ls-remote --tags origin

--------------------------------------------
Подключить/клонировать удаленный репозиторий
--------------------------------------------

** Cоздать связь между локальным и удаленным репозиториями:
		(выполнять из папки локального репозитория)
$	git remote add <https://ssh_link_remote-repo> <local_name_repo_при-необходимости>		# по умолчанию присваивается имя - "origin"
													## название origin, хотя и предлагается по умолчанию, не является обязательным — его можно изменить.
		# Например: git@github.com:igorsimdyanov/hello.git
			##Здесь git — имя пользователя на сервере, github.com — адрес сервера, а igorsimdyanov/hello.git — путь к репозиторию на сервере.
		# Команда git remote add origin регистрирует удаленный сервер в файле .git/config.

** Полностью склонировать удаленный репозиторий в локальную папку:
		(При этом сохраняется связь между локальным (клоном) и удаленным репозиторием)
$	git clone <https://link_remote-repo>
		
	--//-- <ЛОКАЛЬНОЕ_ИМЯ>		#позволяет задать локальное имя (имя папки в которой будет храниться) клонируемому репозиторию.

!!! Cсылка для клонирования может начинаться с префикса https или git@ — это разные протоколы общения с git-сервером.
	git@ - требует наличие на git-сервере открытого ключа (удобен для собственного репозитория).
	https:// мы можем читать репозиторий без ограничений. Но требует прав (доступ, логин/пароль) для внесения изменений!!!


** Посмотреть список удаленных репозиториев, привязанных к текущему проекту:
$	git remote

--------------------------------------
Синхронизация с удаленным репозиторием
--------------------------------------
** Подгрузить обновления из репозитория (обновляет список доступных для загрузки веток)
$	git fetch

** Скачать последние обновления ветки
$	git pull

** Загрузить в репозиторий локальные изменения
$	git push
		 -u <alias_repo><branch>
			# создать в удаленном репозитории новую ветку и загрузить в нее локальные изменения (или --set-upstream)
		 --delete <alias_repo> <branch>	# зафиксировать удаление указанной ветки из удаленного репозитория (после удаления из локального)
		 --force	# принудительно перезаписать историю (после выполнения git rebase в локальном репозитории)
		<tag>	# пуш определенного коммита
		 --tags - загрузка тегов в удаленный репозиторий (после пуша изменений)
		 --delete <alias_repo> <tag>	# удаление указанного тега из удаленного репозитория
		:<имя_ветки>		#удалить ветку из удаленного репозитория
		:<tag>		#удалить тэг из удаленного репозитория