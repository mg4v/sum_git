-------------
Установка Git
-------------
** В Debian:
#	apt install git

** Вывести номер установленной версии:
$	git --version

-------------
Настройка Git
-------------

$	git config
		--global		# Глобальная пользовательская настройка
			user.name "[name]"				# задать имя пользователя
			user.email "[email address]"	# -//- почтовый адрес -//-
			color.ui auto					# -//- автоматическую подсветку синтаксиса
			core.editor "[program]"			# -//- редактор текста по умолчанию (vi, vim, nano, mcedit, emacs и.т.д.)
		--list			# вывести список настроек Git
			--show-origin	# определить местоположение конфигурационного файла git-а
										# конфигурационный файл git-а можно править руками

--------------------
Создание репозитория
--------------------

** Cоздать локальный репозиторий в текущей папке:
$	git init

** Cоздать связь между локальным и удаленным репозиториями:
		(выполнять из папки локального репозитория)
$	git remote add <https://ssh_link_remote-repo> <local_name_repo_при-необходимости>		# по умолчанию присваивается имя - "origin"
													## название origin, хотя и предлагается по умолчанию, не является обязательным — его можно изменить.
		# Например: git@github.com:igorsimdyanov/hello.git
			##Здесь git — имя пользователя на сервере, github.com — адрес сервера, а igorsimdyanov/hello.git — путь к репозиторию на сервере.
		# Команда git remote add origin регистрирует удаленный сервер в файле .git/config.


** Полностью склонировать удаленный репозиторий в локальную папку:
		(При этом сохраняется связь между локальным (клоном) и удаленным репозиторием)
$	git clone <https://link_remote-repo>
		
	--//-- <ЛОКАЛЬНОЕ_ИМЯ>		#позволяет задать локальное имя (имя папки в которой будет храниться) клонируемому репозиторию.


!!! Cсылка для клонирования может начинаться с префикса https или git@ — это разные протоколы общения с git-сервером.
	git@ -  требует наличие на git-сервере открытого ключа (удобен для собственного репозитория).
	https:// мы можем читать репозиторий без ограничений. Но требует прав (доступ, логин/пароль) для внесения изменений!!!


** Посмотреть список удаленных репозиториев, привязанных к текущему проекту:
$	git remote
--------------------------------------
Синхронизация с удаленным репозиторием
--------------------------------------
** Подгрузить обновления из репозитория (обновляет список доступных для загрузки веток)
$	git fetch

** Скачать последние обновления ветки
$	git pull

** Загрузить в репозиторий локальные изменения
$	git push
		 -u <alias_repo><branch>
			# создать в удаленном репозитории новую ветку и загрузить в нее локальные изменения (или --set-upstream)
		 --delete <alias_repo> <branch>	# зафиксировать удаление указанной ветки из удаленного репозитория (после удаления из локального)
		 --force	# принудительно перезаписать историю (после выполнения git rebase в локальном репозитории)
		<tag>	# душ определенного коммита
		 --tags - загрузка тегов в удаленный репозиторий (после пуша изменений)
		 --delete <alias_repo> <tag>	# удаление указанного тега из удаленного репозитория
		:<имя_ветки>		#удалить ветку из удаленного репозитория
		:<tag>		#удалить тэг из удаленного репозитория

--------------------
Работа с изменениями
--------------------

** Проверка репозитория на необходимость фиксации изменений
$	git status
		-s		#упрощенный вывод - только перечень файлов:
					## ?? - неотслеживаемый, A - отслеживаемый, M - модифицированный;

** Вывод изменений (сравнение):
$	git diff		#Покажет различия между файлами в последнем снимке и текущим состоянием (показывает изменения только в отслеживаемых файлах!!!).
		--cached	#Показывает изменения которые попали в индекс (после git add), готовые к коммиту.

** Откатить состояние файла до последнего коммита:
$	git checkout -- <file_name>

** Добавить файл к будущему коммиту (добавить в индекс)
$	git add <file>
		.	# добавляет в индекс все новые файлы
** Записать коммит (зафиксировать изменения)
$	git commit - записать коммит (зафиксировать изменения)
		-a						# добавить в индекс и зафиксировать изменения (используется для уже добавленных ранее файлов)
		-m 'commit message'		# записать коммит с сообщением
		--amend					# записать изменения в последний коммит (!!!перед этим добавить изменения в индекс!)
** Просмотреть информацию о коммите:
$	git show		# информация о текущем коммите;
		<tag>		# информация по конкретному тэгу;
		<commit>	# информация по конкретному коммиту;
		HEAD		# указывает на последний коммит;


-----------------------------------
Работа с временным хранилищем Stash
-----------------------------------
!!! Перед "откладыванием" изменений их необходимо проиндексировать (git add)!!!

$	git stash
		list				# посмотреть список stash хранилищ
		apply				# вернуть изменения спрятанные в stash списке
						## Каждое сохранение в stash маркируется номером stash-записи (метки).
						## Apply, по умолчанию, возвращает изменения с последней меткой.
			stash@{номер_метки}	# Вернуть изменения сохраненные под определенным номером.
		drop				# Удалить все записи в stash
		push <file>			# добавить файл в существующий на текущей ветке stash
		pop <stash>			# применить изменения из stash хранилища с указанным номером

-----------------
Работа с историей
-----------------

** Просмотр истории коммитов:
$	git log
		--oneline	# просмотр истории коммитов кратким списком (сокращенный хэш)
		--all		# посмотреть истории коммитов со всех веток
		-<число>	# ограничить вывод количеством последних коммитов
		-p		# детальная информация по коммитам
		--stat		# вывод статистики по каждому коммиту
		--pretty=<формат_вывода>	# вывод истории в указанном формате
			oneline	# тоже что и --oneline, но хэш коммитов указывается полностью
			format: "%<имя_столбца(цвет, если нужно)> - %<имя_столбца>, %<имя_столбца> : %<имя_столбца>"		# указать свой формат вывода отчета по истории:
				h	# сокращенный хеш
				an	# автор
				ar	# сколько времени назад добавлен
				s	# комментарий
		--until=<число><единица_времени>		# позволяет задать дату, с которой мы начинаем поиск, например - 2.week
		--since=<число><единица_времени>		# задать, до какого момента в прошлом мы ищем коммиты.
								## допускается использовать и точные даты типа: 2019-03-01
		-S<искомый_текст>				# поиск коммита где добавлен этот текст
		-​-author="имя_автора"				# вывод коммитов указанного автора
		--graph						# кометы со всех веток с зависимостями (включая слияния)
		--date=format:"%d.%m.%Y %H:%M			# задаем формат времени в выводе
		
** Вывести список коммитов по конкретному файлу:
$	git blame <имя_файла>
	

** Просмотр истории действий:
$	git reflog

** Сброс текущего состояния истории до указанного коммита:
$	git reset
		--hard			# жесткий сброс без сохранения изменений
		HEAD <filename>		# удалить изменения внесенные в индекс - вернув к последнему комету текущей ветки.

** Cоздать новый коммит, отменяющий  последствия указанного коммита:
$	git revert <hash_commit>

** Cброс состояния файла до последнего коммита:
$	git restore <file>

----------------
Работа с ветками
----------------
** Показать ветки (знак "*" перед именем ветки - обозначает текущую ветку):
$	git branch
			<branch>			# создается новая ветка
			<branch_fork> <branch_parent>	# создать новую ветку от указанной ветки
			-d <branch>			# удалить указанную ветку
			-m <original_name final_name>	# сменить имя ветки
				# !!!если потребуется переименовать удаленную ветку, то сделать это одной командой довольно сложно. Проще всего создать на удаленном сервере копию ветки, а старую ветку удалить.
				# git branch <новая_ветка> origin/<с_какой_копируем>; git push origin <новая_ветка>; git push origin :<с_какой_копировали>
			-r				# показать список веток в удаленном репозитории

** Если в качестве командной оболочки используется bash, можно воспользоваться решением git-aware-promt (​https://github.com/jimeh/git-aware-prompt)​,
	который встраивает название текущей ветки в подсказку командной строки.
===>
$	cd
$	mkdir .bash
$	cd​.bash
$	git ​clone​https://github.com/jimeh/git-aware-prompt.git
*** При помощи команды source выполняется скрипт main.sh из проекта git-aware-prompt.
$	source​​"~/.bash/git-aware-prompt/main.sh
*** Модифицируем переменную окружения PS1 таким образом, чтобы в нее добавлялось название текущей ветки:
	export​PS1=​"\w \[\$txtcyn\]\$git_branch\[\$txtred\]\$git_dirty\[\$txtrst\]\$ "
$	cd​​ <имя_проекта>	#должна смениться строка приглашения на вид: <имя_проекта>​(<имя_ветки>)<статус_репозитория>$

<===


** Переключится на указанную ветку:
$	git checkout <branch>
		-b <branch>	# создать новую ветку и переключиться на нее
			<tag>	# создать ветку от коммита, помеченного указанным коммитом, и переключиться на нее.


** Слияние указанной ветки в текущую ветку:
$	git merge <branch>
		<branch> --squash		# перенос всех изменений (слияние) с указанной ветки в текущую одним коммитом через squash

**	Cмена начала старта текущей ветки с последнего коммита указанной ветки без добавления нового коммита
$	git rebase <branch>
		-i HEAD~X - склеить Х коммитов начиная с текущего
	# в открывшемся файле можно в нижних коммитах заменить pick на f (fix up - перемещает все сообщения из ранних коммитов в текущий)

-----------------------------------------
Работа с конфликтами (при слиянии веток):
-----------------------------------------
Конфликты обозначаются угловыми скобками (>>>>> , <<<<<), чтобы их было хорошо видно в коде.
В верхней части приводится код текущей ветки, в нижней — той ветви, которая сливается.
Нам нужно выбрать правильный вариант или написать новый, который учтет изменения из обеих частей.
Далее git add и git commit


------------------------------------
Работа с коммитами из соседних веток
------------------------------------
git cherry-pick <commit>	# перенести коммит из другой ветки на текущую ветку
git cherry-pick <branch>	# перенести последний коммит ветки
git cherry-pick ..<branch>	# перенести все коммиты с ветки

-------------------------------------
Работа с метками (также см. git push)
-------------------------------------
** Вывести список тегов
$	git tag
		<tag>				# фиксация версии (релиза) продукта тегом (меткой) по последнему коммиту
		-d <tag>			# удалить тег из локального репозитория
		-a <tag> -m '<комментария>'	# соответсвенно, создаем так с комментарием
		-l <маска>			# поиск тегов по маске.
			<commit>		# присвоить тэг определенному коммиту.

** запросить список тегов с удаленного репозитория

$	git ls-remote --tags origin
-------------
Структура Git
-------------

Репозитории бывают:
	1. Лоакальные (local);
	2. Удаленные (remote);

Структура репозитория:
.git - директория в которой содержится вся конфигурация и снимки репозитория:
	./hooks/
	./info/
	./objects/
	./refs/
	./config
	./description
	./HEAD

Структура истории коммитов:
(HEAD -> <branch>)	# в истории коммитов указывает на текущую ветку
commit				# хэш коммита (используется SHA-1: Это строка длинной в 40 символов в HEX формате
					## Хэш вычисляется на основе содержимого файла или структуры каталога.
					## Для удобства можно сократить хеш до 7-8 символов)
Author				# автор коммита (имя и email)
Date				# дата и время создания коммита


Файлы Git:
README.md	- обычно содержит описание для текущего репозитория либо директории
.gitkeep	- пустой файл, создается в пуостой директории для ее фиксации в репозитории
.gitignore	- в файле указываются названия файлов и дерикторий (можно шаблонами), которые не должны индексироваться в git (помещается в корень проекта)

# Ресурс http://gitignore.io/ позволяет автоматически формировать содержимое .gitignore-файла.
# Достаточно указать ключевые слова, например Sublime, Yii2, vim,
## и на их основе будет предложена заготовка для .gitignore, которая исключает временные и вспомогательные файлы.


Stash - локальное хранилище git для временного хранения изменений в ветке без их индексирования и фиксации

Сразу после создания проекта появляется основная ветка master (или main).


--------------------------------
Версия программного обеспечения:
--------------------------------

Версии программного обеспечения, как правило, состоит из трех цифр, первая из которых называется мажорной, вторая — минорной, а третья — патч-версией.
M.m.pv

Мажорная версия меняется довольно редко, как правило, в случае кардинальной переработки программного продукта.
Минорная версия отвечает за регулярные релизы, в рамках которых добавляется новый функционал и исправляются ошибки.
В рамках патч-версии изменений в возможностях программного обеспечения не производится. Как правило, в рамках такой версии закрываются критические уязвимости.

Это не единственно возможный способ версионирования, например, можно ориентироваться на даты выхода продукта.

Какая бы модель версионирования не была выбрана, в системе контроля версий придется отметить коммит,
	который отвечает за версию, чтобы в любой момент времени иметь возможность собрать нужную версию продукта.
Такие кометы помечаются с помощью тегов (см. git tag).
Тэг — это всегда ссылка на коммит. На один и тот же коммит можно навесить множество тэгов.
Более того, хэш тоже можно рассматривать как тэг, просто его сложнее запомнить. Поэтому мы вводим свои собственные тэги, которые человеку запомнить гораздо проще.
Помимо наших собственных тэгов и хэш-кодов, git предоставляет несколько дополнительных тэгов. Один из них HEAD, указывает на последний коммит:

--------------------
Графические клиенты:
--------------------
** gitk	#запускается из папки проекта, позволяет просматривать историю;
** git-gui	#предназначен для формирования коммитов - можно видеть измененные файлы, понимать, что в них поменялось, добавлять комментарии.
	[Stage Changed] = git add
	[commit] = git commit

----------------
Git репозитории:
----------------
Для того, чтобы начать пользоваться удаленным git-репозиторием, проще всего начать с готовых git-хостингов, например, GitHub или BitBucket.
Кроме хостинга, GitHub предоставляет мощный веб-интерфейс для управления Git-репозиторием,
	трекер задач, Wiki-редактор документации, поиск по проектам, статистику по кодовой базе и многое другое.
Если git-хостинги по каким-то причинам не подходят, можно развернуть свой собственный git-репозиторий:
	для этого достаточно виртуального сервера с SSH-доступом.
В случае, если помимо консольного доступа необходим веб-интерфейс, можно воспользоваться GitLab, который тоже можно развернуть на собственном сервере.
GitLab предоставляет веб-интерфейс для управления git-репозиториями, правами доступа и предоставляет схожий с Git-хостингами функционал.


------------------
Псевдонимы команд:
------------------
Для объемных команд можно использовать короткие запоминающиеся псевдонимы.
Создать псевдоним можно при помощи команды git config, добавив свойство alias, после него следует указать имя псевдонима.
Например:
Введем псевдоним gg для команды ​git log​с параметром -​-graph:​

$ git config --global alias.gg 'log --pretty=format:"%C(yellow)%h%Creset -%C(green)%d%Creset %s %C(bold blue)(%cn) %C(green)%cd%Creset" --graph --date=format:"%d.%m.%Y %H:%M"'

